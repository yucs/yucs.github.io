<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yucs&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yucs.github.io/"/>
  <updated>2017-12-14T12:22:23.000Z</updated>
  <id>https://yucs.github.io/</id>
  
  <author>
    <name>yucs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> Kubernetes之存储学习整理</title>
    <link href="https://yucs.github.io/2017/12/14/2017-12-14-kubernetes_volume/"/>
    <id>https://yucs.github.io/2017/12/14/2017-12-14-kubernetes_volume/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2017-12-14T12:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul><li><p>存储选型思考</p><ul><li>一般应用服务：应用级本身不做数据的冗余，为了数据的安全性，而且这类读写延迟高些也能接受（读写IO路径长，多副本机制，都会增加读写延迟），开源的主流使用ceph（默认采用三副本，设计优雅，理念也是自动化）</li><li>数据类服务：本身为了高可用而使用多副本冗余机制，通常对性能和延时有比较高的要求<ul><li>简单方案可以采用如hostpath等本地存储方案，妥协点是数据无法迁移（当然，一般数据类系统 添加删除节点时，本身有负载均衡功能，所以可以通过  删除节点，添加新节点 这种“迁移”方式，迁移过程就是对服务有可能所影响）</li><li>使用网络块存储（block device）（性能高的SAN存储）: 跟平台解耦，灵活迁移，代价就是延时有些高，性能有些低（像couchbase 这类内存Nosql，数据在内存，通过异步刷新数据到磁盘 ，对磁盘读写延迟一些可以接受的）</li></ul></li></ul></li><li><p>开发存储插件</p><ul><li>背景：X银行往往有自己的高性能的SAN存储系统，需要进行对接，块设备挂载本地后使用LVM。<ul><li>基于<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/flexvolume.md" target="_blank" rel="noopener">FlexVolume</a>:  <a href="https://github.com/kubernetes/kubernetes/tree/master/examples/volumes/flexvolume" target="_blank" rel="noopener">lvm</a> 根据需求二次定制就好了。</li><li>（可选）参考<a href="https://github.com/kubernetes-incubator/external-storage" target="_blank" rel="noopener">external-storage</a>:<a href="https://github.com/kubernetes-incubator/external-storage/tree/master/docs/demo/hostpath-provisioner" target="_blank" rel="noopener">hostPath demo</a></li></ul></li></ul></li></ul><ul><li>参考TiDB关于本地存储的解决方案部分：<a href="https://zhuanlan.zhihu.com/p/27229692?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="noopener">黄东旭DTCC2017演讲实录：When TiDB Meets Kubernetes</a></li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><a href="https://feisky.gitbooks.io/kubernetes/concepts/volume.html" target="_blank" rel="noopener">kubernetes指南：存储</a></p><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://ibm.biz/opentech-ma" target="_blank" rel="noopener">IBM开源技术微讲堂:Kubernetes的存储管理</a>（好）</p><ul><li><p>volume :</p><ul><li><p>Kubernetes Volume的生命周期与Pod绑定,容器挂掉后Kubelet再次重启容器时，Volume的数据依然还在.</p></li><li><p>而Pod删除时，Volume才会清理。数据是否丢失取决于具体的Volume类型，比如emptyDir的数据会丢失，而PV的数据则不会丢. (官方文档: which is erased when a Pod is removed, the contents of a cephfs volume(其他网络存储一样，即PV) are preserved and the volume is merely unmounted.)</p></li><li>限制：<ul><li>声明POD时，暴露出存储细节， 一般用户视角来说，可能不关心，有一定的耦合。</li><li>不包含对第三方存储的管理：在声明POD前，对于第三方存储，要先创建好对应的volume,删除POD也需要手动删除volume资源。</li></ul></li></ul></li><li><p>PV(Persistent Volumes)，PersistentVolumeClaim (PVC),StorageClass:</p><ul><li>为了解决volume的限制，更加方便自动化。</li><li>概念：<ul><li>PersistentVolume（PV）是集群之中的一块网络存储。跟 Node 一样，也是集群的资源。相对于 Volume 会有独立于 Pod 的生命周期（有 PV controller来实现PV/PVC的生命周期）。</li><li>而PersistentVolumeClaim (PVC) 是对 PV 的请求,pod声明使用它。（ 从Storage Admin与用户的角度看PV与PVC :Admin创建和维护PV; 用户只需要使用PVC(size &amp; access mode).</li><li>StorageClass来动态创建PV，不仅节省了管理员的时间，还可以封装不同类型的存储供PVC选用。就是封装了对第三方网络存储的管理操作，这样就不用手动创建volume或者手动声明一个PV。（所以，最灵活做法声明POD使用PVC,而PVC使用StorageClass）。</li></ul></li></ul></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="http://ibm.biz/opentech-ma" target="_blank" rel="noopener">IBM开源技术微讲堂:Kubernetes的存储管理</a> </p><p><a href="http://newto.me/k8s-storage-architecture/" target="_blank" rel="noopener">Kuberenetes 存储架构总体介绍</a></p><p><a href="http://newto.me/k8s-csi-design/" target="_blank" rel="noopener">Kubernetes存储介绍系列 ——CSI plugin设计</a></p><p><a href="http://newto.me/k8s-adcontroller-caches/" target="_blank" rel="noopener">Kubernetes存储介绍系列 —— AttachDetachController1</a></p><p><a href="http://dockone.io/article/2082" target="_blank" rel="noopener">Kubernetes 存储功能和源码深度解析（一）</a></p><p><a href="http://dockone.io/article/2087" target="_blank" rel="noopener">Kubernetes 存储功能和源码深度解析（二）</a></p><p><img src="https://yucs.github.io/picture/K8S_volume_arch.png" alt="K8S_volume_arch"><br><img src="https://yucs.github.io/picture/k8s_volume_arch2.png" alt="k8s_volume_arch2"></p><ul><li>Volume Plugins <ul><li>存储提供的扩展接口, 包含了各类存储提供者的plugin实现。</li><li>实现自定义的Plugins 可以通过FlexVolume(K8s 1.8版本，目前算是过度方案)</li><li>kubernetes 1.9以后可能推荐CSI（Container Storage Interface）用方式来实现。<ul><li>支持这套标准以后，K8S和存储提供者之间将彻底解耦，终极目标是将存储的所有的部件作为sidecar container运行在K8S上（当前K8s 1.8版本设计还没有完全做到，需要一个兼容的发展周期），而不再作为K8S部件运行在host上。</li></ul></li></ul></li><li>Volume Manager <ul><li>运行在kubelet 里让存储Ready的部件，主要是mount/unmount（attach/detach可选）</li><li>pod调度到这个node上后才会有卷的相应操作，所以它的触发端是kubelet（严格讲是kubelet里的pod manager），根据Pod Manager里pod spec里申明的存储来触发卷的挂载操作<ul><li>Kubelet会监听到调度到该节点上的pod声明，会把pod缓存到Pod Manager中，VolumeManager通过Pod Manager获取PV/PVC的状态，并进行分析出具体的attach/detach、mount/umount, 操作然后调用plugin进行相应的业务处理</li></ul></li></ul></li><li><p>PV/PVC Controller </p><ul><li>运行在Master上的部件，主要做provision/delete</li><li>PV Controller和K8S其它组件一样监听API Server中的资源更新，对于卷管理主要是监听PV，PVC， SC三类资源，当监听到这些资源的创建、删除、修改时，PV Controller经过判断是需要做创建、删除、绑定、回收等动作。</li></ul></li><li><p>Attach/Detach Controller</p><ul><li>运行在Master上，主要做一些块设备（block device）的attach/detach（eg:rbd,cinder块设备需要在mount之前先挂载到主机上，看源码看哪那些实现了Attah接口)</li><li>非必须controller: 为了在attach卷上支持plugin headless形态，Controller Manager提供配置可以禁用。  </li><li>它的核心职责就是当API Server中，有卷声明的pod与node间的关系发生变化时，需要决定是通过调用存储插件将这个pod关联的卷attach到对应node的主机（或者虚拟机）上，还是将卷从node上detach掉.</li></ul></li><li><p>K8s挂载卷的基本过程</p><ul><li>用户创建Pod包含一个PVC</li><li>Pod被分配到节点NodeA</li><li>Kubelet等待Volume Manager准备设备</li><li>PV controller调用相应Volume Plugin(in-tree或者out-of-tree)创建持久化卷并在系统中创建 PV对象以及其与PVC的绑定(Provision)</li><li>Attach/Detach controller或者Volume Manager通过Volume Plugin实现块设备挂载(Attach)<ul><li>Volume Manager等待设备挂载完成，将卷挂载到节点指定目录(mount)</li><li>/var/lib/kubelet/plugins/kubernetes.io/aws-ebs/mounts/vol-xxxxxxxxxxxxxxxxx</li><li>Kubelet在被告知设备准备好后启动Pod中的容器，利用Docker –v等参数将已经挂载到本地 的卷映射到容器中(volume mapping)</li></ul></li></ul></li><li><p>PV &amp; PVC状态图<br>PV的状态图：<br>  <img src="https://yucs.github.io/picture/PV_status.png" alt="pv"><br> PVC的状态图:<br>  <img src="https://yucs.github.io/picture/pvc_status.png" alt="pvc"></p></li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>Volume Manager : <a href="http://www.voidcn.com/article/p-dtoyjptm-bog.html" target="_blank" rel="noopener">kubernetes数据卷管理源码分析</a></p><ul><li><p>kubelet管理volume的方式基于两个不同的状态：</p><ul><li>DesiredStateOfWorld：预期中，pod对volume的使用情况，简称预期状态。当pod.yaml定制好volume，并提交成功，预期状态就已经确定.</li><li>ActualStateOfWorld：实际中，pod对voluem的使用情况，简称实际状态。实际状态是kubelet的后台线程监控的结果.</li></ul></li><li><p>vm.desiredStateOfWorldPopulator.Run方法根据从apiserver同步到的pod信息，来更新DesiredStateOfWorld。另外一个方法vm.reconciler.Run，是预期状态和实际状态的协调者，它负责将实际状态调整成与预期状态。预期状态的更新实现，以及协调者具体如何协调.</p></li></ul><p>PVcontroller: <a href="http://dockone.io/article/2087" target="_blank" rel="noopener">Kubernetes 存储功能和源码深度解析（二）</a></p><h1 id="开发资源"><a href="#开发资源" class="headerlink" title="开发资源"></a>开发资源</h1><ul><li><p>volume plugin</p><ul><li>基于<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/flexvolume.md" target="_blank" rel="noopener">FlexVolume</a>:  <a href="https://github.com/kubernetes/kubernetes/tree/master/examples/volumes/flexvolume" target="_blank" rel="noopener">lvm</a></li><li>基于<a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">CSI</a>: 等待 k8s release 版本支持后</li></ul></li><li><p>Out-of-Tree Provisioner</p><ul><li>由于在Pod中声明volume有局限性，要更灵活的化，就需要pv controller等进行生命周期的管理。</li><li><a href="https://github.com/kubernetes-incubator/external-storage" target="_blank" rel="noopener">external-storage</a>:<a href="https://github.com/kubernetes-incubator/external-storage/tree/master/docs/demo/hostpath-provisioner" target="_blank" rel="noopener">hostPath demo</a></li></ul></li></ul><hr><p>本文出处：<a href="https://yucs.github.io/2017/12/14/2017-12-14-kubernetes_volume/">https://yucs.github.io/2017/12/14/2017-12-14-kubernetes_volume/</a></p><p>markdown文件放在 <a href="https://github.com/yucs/yucs-awesome-resource" target="_blank" rel="noopener">github.com/yucs/yucs-awesome-resource</a> 持续更新，欢迎star ,watch</p><p>如有出入请请教，文章持续更新中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存储选型思考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般应用服务：应用级本身不做数据的冗余，为了数据的安全性，而且这类读写延迟高些也能
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://yucs.github.io/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://yucs.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title> 分布式系统之基础介绍</title>
    <link href="https://yucs.github.io/2017/12/09/2017-12-9-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>https://yucs.github.io/2017/12/09/2017-12-9-分布式系统原理之基础介绍/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2017-12-14T12:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习分布式系统要先了解该系统的整体架构，各个组件作用功能，运行时态的各个组件间互动的关系，核心主逻辑的在各个组件的调用逻辑。整体架构把握后，然后再看各个组件具体工作原理，再进一步看源码了解细节。</p><h1 id="《分布式系统原理介绍》第一章"><a href="#《分布式系统原理介绍》第一章" class="headerlink" title="《分布式系统原理介绍》第一章"></a>《分布式系统原理介绍》第一章</h1><ul><li><p>分布式系统模型：<br><img src="https://yucs.github.io/picture/分布式系统模型.png" alt="分布式系统模型"> </p></li><li><p>异常是常态：分布式系统核心问题之一就是处理各种异常(failure)情况。</p></li><li><p>TCP 协议保证了 TCP 协议 栈之间的可靠的传输，但无法保证两个上层应用之间的可靠通信，往往应用间需要确认消息。（使用RPC就可以在应用层确认消息，某种程度算是应用层的可靠通信）</p><ul><li>题外话：应用程序调用接口保存数据，返回成功也不一定意味着真实落盘，因为通常为了性能，不使用直写模式，数据只会写入操作系统内核缓存区就返回成功了，尤其使用分布式文件系统，IO路径更长。</li></ul></li></ul><ul><li><p>由于网络异常的存在，分布式系统中请求结果存在“三态”的概念：成功、 失败、 超时(未 知)。对于超时的请求，我们无法获知该 请求是否被节点 B 成功执行了，因此要特殊处理，一种简单处理方式，就是调用接口要幂等性（分布式系统设计中，幂等性很重要，可以保证系统状态的正确性）。<br><img src="https://yucs.github.io/picture/rpc_failure.png" alt="rpc_failure"></p></li><li><p>在工程实践中，大量异常情况是无法预先可知的：例如，磁盘故障会导致 IO 操作缓慢，从而有可能使得进程运行速度非常慢，进而对整个系统会造成影响。又例如网络不稳定时也会引起“半死不活”异常，例如网络发生严重 拥塞时约等于网络不通，过一会儿又恢复，恢复后又拥塞，如此交替。</p></li><li><p>被大量工程实践所检验过的异常处理黄金原则是:任何在设计阶段考虑到的异常情况一定会在 系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需 求指标允许，在系统设计时不能放过任何异常情况。</p></li><li><p>工程中常常容易出问题的一种思路是认为某种异常出现的概率非常小以至于可以忽略不计。（墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；<br>四、如果你担心某种情况发生，那么它就更有可能发生。）</p></li></ul><ul><li>衡量分布式系统的指标<ul><li>可扩展性(scalability) : 指分布式系统通过扩展集群机器规模 高系统性能(吞吐、延迟、 并发)、存储容量、计算能力的特性。可扩展性是分布式系统的特有性质。分布式系统的设计初衷就 是利用集群多机的能力处理单机无法解决的问题. </li><li>可用性：可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</li><li>性能指标：系统的吞吐能力，QPS(query per second)，系统的响应延迟。追求高吞吐的系统，往往很难做到低延迟;系统平均响应时间较长时，也很难提高QPS。(参考：<a href="http://www.cnblogs.com/data2value/p/6220859.html" target="_blank" rel="noopener">吞吐量（TPS）、QPS、并发数、响应时间（RT）概念</a>和<a href="http://www.ha97.com/5095.html" target="_blank" rel="noopener">系统吞吐量（TPS）、用户并发量、性能测试概念和公式</a>)</li><li>一致性: 分布式系统为了高可用性，总是不可避免的使用副本的冗余机制，从而引发副本一致性的问题。</li></ul></li></ul><h1 id="Introduction-to-Distributed-System-Design"><a href="#Introduction-to-Distributed-System-Design" class="headerlink" title="Introduction to Distributed System Design"></a>Introduction to Distributed System Design</h1><p><a href="http://www.hpcs.cs.tsukuba.ac.jp/~tatebe/lecture/h23/dsys/dsd-tutorial.html" target="_blank" rel="noopener">Introduction to Distributed System Design</a></p><p><a href="http://dockone.io/article/967?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">彻底厘清真实世界中的分布式系统</a></p><p><a href="http://dockone.io/article/898" target="_blank" rel="noopener">当讨论分布式系统时，我们都会讨论些什么？</a></p><ul><li><p>有关分布式计算的几个谬论: 网络是可靠的。延迟为零。带宽是无限的。网络是安全的。拓扑不会改变。肯定有一个管理员。传输的代价为零。网络是同质的。</p></li><li><p>常见异常：</p><ul><li>Halting failures: A component simply stops. There is no way to detect the failure except by timeout: it either stops sending “I’m alive” (heartbeat) messages or fails to respond to requests. Your computer freezing is a halting failure.</li><li>Fail-stop: A halting failure with some kind of notification to other components. A network file server telling its clients it is about to go down is a fail-stop.<br>Omission failures: Failure to send/receive messages primarily due to lack of buffering space, which causes a message to be discarded with no notification to either the sender or receiver. This can happen when routers become overloaded.</li><li>Network failures: A network link breaks.<br>Network partition failure: A network fragments into two or more disjoint sub-networks within which messages can be sent, but between which messages are lost. This can occur due to a network failure.</li><li>Timing failures: A temporal property of the system is violated. For example, clocks on different computers which are used to coordinate processes are not synchronized; when a message is delayed longer than a threshold period, etc.</li><li>Byzantine failures: This captures several types of faulty behaviors including data corruption or loss, failures caused by malicious programs, etc.</li></ul></li><li><p>分布式系统特性：</p><ul><li>Fault-Tolerant: It can recover from component failures without performing incorrect actions.</li><li>Highly Available: It can restore operations, permitting it to resume providing services even when some components have failed.</li><li>Recoverable: Failed components can restart themselves and rejoin the system, after the cause of failure has been repaired.</li><li>Consistent: The system can coordinate actions by multiple components often in the presence of concurrency and failure. This underlies the ability of a distributed system to act like a non-distributed system.</li><li>Scalable: It can operate correctly even as some aspect of the system is scaled to a larger size. For example, we might increase the size of the network on which the system is running. This increases the frequency of network outages and could degrade a “non-scalable” system. Similarly, we might increase the number of users or servers, or overall load on the system. In a scalable system, this should not have a significant effect.</li><li>Predictable Performance: The ability to provide desired responsiveness in a timely manner.</li><li>Secure: The system authenticates access to data and services</li></ul></li></ul><p>很难设计出包含全部特性的分布式系统，因此在设计系统要根据具体需求做权衡了。尤其在数据类分布式系统，经典就是CAP，BASE,ACID理论了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习分布式系统要先了解该系统的整体架构，各个组件作用功能，运行时态的各个组件间互动的关系，核心主逻辑的在各个组件的调用逻辑。整体架构把握后，然后再看各个组件具体工作原理，再进一步看源码了解细节。&lt;/p&gt;
&lt;h1 id=&quot;《分布式系统原理介绍》第一章&quot;&gt;&lt;a href=&quot;#《
      
    
    </summary>
    
      <category term="分布式系统" scheme="https://yucs.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="https://yucs.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title> Kubernetes网络插件CNI学习整理</title>
    <link href="https://yucs.github.io/2017/12/06/%202017-12-6-CNI/"/>
    <id>https://yucs.github.io/2017/12/06/ 2017-12-6-CNI/</id>
    <published>2017-12-05T16:00:00.000Z</published>
    <updated>2017-12-14T02:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul><li><p>项目背景（XX银行客户）：私有云上要在K8S上跑像mysql这类状态的数据库服务，对性能和延时都比较敏感，并不像web偏应用的无状态延时性能差点可接受。而基于overlay方式等网络性能和延时比较差，网络架构又比较复杂。并且银行对于IP网络管理需要简单可控。SR-IOV是基于硬件实现虚拟网卡，性能损失少，接近宿主机，此外有支持QOS,vlan等特性也是客户需要的。即要根据用户定制基于SR-IOV网络插件。</p></li><li><p>问题： 目前kubernetes（1.8）（以后版本可能支持大）中，POD并没有网络相关的配置，kubelete 调用 CNI plugin 默认只会以CNI_ARGS传入pod_name基本信息。如果要固定分配IP地址，以及配置QOS,vlan等网络特性，没法通过CNI_ARGS方式传入，不能像volume一样在pod SPEC中配置options可选的网络参数来传入cni plugin。 </p></li></ul><ul><li>一种可行解决方案：声明一个POD前，先根据pod_name来在外部configMap或其他地方存放网络配置信息，定制的CNI，IPAM的网络插件根据pod_name来从外部获取配置信息。</li></ul><h1 id="CNI工作原理"><a href="#CNI工作原理" class="headerlink" title="CNI工作原理"></a>CNI工作原理</h1><p><a href="https://github.com/feiskyer/kubernetes-handbook/blob/master/network/cni/index.md" target="_blank" rel="noopener">Kubernetes指南  cni</a></p><p><a href="http://cizixs.com/2017/05/23/container-network-cni" target="_blank" rel="noopener">CNI：容器网络接口</a></p><ul><li>网络插件是独立的可执行文件，被上层的容器管理平台调用。网络插件只有两件事情要做：把容器加入到网络以及把容器从网络中删除。</li><li>调用插件的数据通过两种方式传递：环境变量和标准输入。</li><li>kubernetes 使用了 CNI 网络插件之后 工作流程：<ul><li>kubernetes 先创建 pause 容器生成对应的 network namespace</li><li>调用网络 driver（因为配置的是 CNI，所以会调用 CNI 相关代码</li><li>CNI driver 根据配置调用具体的 cni 插件</li><li>cni 插件给 pause 容器配置正确的网络,pod 中其他的容器都是用 pause 的网络.</li></ul></li></ul><p><a href="http://dockone.io/article/2901" target="_blank" rel="noopener">Kubernetes的网络接口CNI及灵雀云的实践</a></p><ul><li>运维人员视角，在传统运维工作强调对IP要有很强的管控（银行等），POD需要固定IP:<ul><li>于运维来说，网络方面是很重要的资源，要对IP进行强管控，服务来回飘，会让他的安全感下降很多。</li><li>运维服务有很多基于IP的东西，有流量和突发的监控，如果你服务的IP一直变化，通过这个IP它很难用到这个服务，相当于IP的监控就没有意义，因为根本不知道IP流量上去了是哪个服务的，很难对应到这个事。</li><li>还有是对于IP安全策略没有办法做。</li><li>kubelet 与 CNI plugin调用逻辑图：<br><img src="https://yucs.github.io/picture/CNI.png" alt="cni"></li></ul></li></ul><ul><li><a href="https://thenewstack.io/hackers-guide-kubernetes-networking/" target="_blank" rel="noopener">hackers-guide-kubernetes-networking</a><ul><li>Kubernetes unfortunately still supports only one CNI interface per POD with one cluster-wide configuration. This is very limiting since we may want to configure multiple network interfaces per POD, potentially using different overlay solutions with different policies (subnet, security, QoS).</li><li>Kubelet will pass the POD name and namespace as part of the CNI_ARGS variable (for example “K8S_POD_NAMESPACE=default;K8S_POD_NAME=mytests-1227152546-vq7kw;” ). We can use this to customize the network configuration per POD or POD namespace (e.g. put every namespace in a different subnet). </li><li>Future Kubernetes versions will treat networks as equal citizens and include network configuration as part of the POD or namespace spec just like memory, CPUs and volumes. For the time being, we can use annotations to store configuration or record POD networking data/state.</li><li><a href="https://github.com/Intel-Corp/multus-cni" target="_blank" rel="noopener">multus-cni</a></li></ul></li></ul><ul><li><a href="http://blog.csdn.net/waltonwang/article/details/72669826" target="_blank" rel="noopener">从源码看kubernetes与CNI Plugin的集成</a> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  //kubernetes/pkg/kubelet/network/cni/cni.go</span><br><span class="line">  func (plugin *cniNetworkPlugin) buildCNIRuntimeConf(podName string, podNs string, podSandboxID kubecontainer.ContainerID, podNetnsPath string) (*libcni.RuntimeConf, error) &#123;</span><br><span class="line">rt := &amp;libcni.RuntimeConf&#123;</span><br><span class="line">ContainerID: podSandboxID.ID,</span><br><span class="line">NetNS:       podNetnsPath,</span><br><span class="line">IfName:      network.DefaultInterfaceName,</span><br><span class="line">Args: [][2]string&#123;</span><br><span class="line">&#123;&quot;IgnoreUnknown&quot;, &quot;1&quot;&#125;,</span><br><span class="line">&#123;&quot;K8S_POD_NAMESPACE&quot;, podNs&#125;,</span><br><span class="line">&#123;&quot;K8S_POD_NAME&quot;, podName&#125;,</span><br><span class="line">&#123;&quot;K8S_POD_INFRA_CONTAINER_ID&quot;, podSandboxID.ID&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //libcni </span><br><span class="line">func (c *CNIConfig) AddNetwork(net *NetworkConfig, rt *RuntimeConf)</span><br><span class="line">  invoke.ExecPluginWithResult(pluginPath, net.Bytes, c.args(&quot;ADD&quot;, rt))</span><br><span class="line">    //将RuntimeConf.Args以环境变量方式传入。</span><br><span class="line">    stdoutBytes, err := e.RawExec.ExecPlugin(pluginPath, netconf, args.AsEnv())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> type CNI interface &#123;</span><br><span class="line">AddNetworkList(net *NetworkConfigList, rt *RuntimeConf) (types.Result, error)</span><br><span class="line">DelNetworkList(net *NetworkConfigList, rt *RuntimeConf) error</span><br><span class="line"></span><br><span class="line">AddNetwork(net *NetworkConfig, rt *RuntimeConf) (types.Result, error)</span><br><span class="line">DelNetwork(net *NetworkConfig, rt *RuntimeConf) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RuntimeConf struct &#123;</span><br><span class="line">ContainerID string</span><br><span class="line">NetNS       string</span><br><span class="line">IfName      string</span><br><span class="line">Args        [][2]string</span><br><span class="line">// A dictionary of capability-specific data passed by the runtime</span><br><span class="line">// to plugins as top-level keys in the &apos;runtimeConfig&apos; dictionary</span><br><span class="line">// of the plugin&apos;s stdin data.  libcni will ensure that only keys</span><br><span class="line">// in this map which match the capabilities of the plugin are passed</span><br><span class="line">// to the plugin</span><br><span class="line">CapabilityArgs map[string]interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CNI开发参考资源"><a href="#CNI开发参考资源" class="headerlink" title="CNI开发参考资源"></a>CNI开发参考资源</h1><ul><li><a href="https://github.com/keontang/k8s-notes/blob/master/kubernetes-network.md" target="_blank" rel="noopener">CNI源码分析</a>(比较系统)</li><li><a href="http://www.cnblogs.com/YaoDD/p/7419383.html" target="_blank" rel="noopener">深入理解CNI</a></li><li><a href="https://github.com/containernetworking/cni/blob/master/SPEC.md" target="_blank" rel="noopener">CNI spec 文档</a></li><li>官方维护的plugin插件: <a href="https://github.com/containernetworking/plugins" target="_blank" rel="noopener">plugins</a></li><li>用cnitool 调试自己编写的plugin：<a href="https://github.com/containernetworking/cni/tree/master/cnitool" target="_blank" rel="noopener">cnitool</a></li><li>用脚本运行容器测试自己plugin:<a href="https://github.com/containernetworking/cni#running-a-docker-container-with-network-namespace-set-up-by-cni-plugins" target="_blank" rel="noopener">docker-run.sh</a></li><li>官方plugin sample:<a href="https://github.com/containernetworking/plugins/tree/master/plugins/sample" target="_blank" rel="noopener">sample</a></li></ul><h1 id="kubelet原理"><a href="#kubelet原理" class="headerlink" title="kubelet原理"></a>kubelet原理</h1><ul><li><a href="https://feisky.gitbooks.io/kubernetes/components/kubelet.html" target="_blank" rel="noopener">Kubernetes指南 kubelet</a></li><li><a href="http://cizixs.com/2016/10/25/kubernetes-intro-kubelet" target="_blank" rel="noopener">kubernetes 简介：kubelet 和 pod</a>  <ul><li>它的核心工作是监听 apiserver,配置目录(默认/etc/kubernetes/manifests/)等清单，一旦发现当前节点的 pod 配置发生变化，就根据最新的配置执行响应的动作，保证运行的 pod 状态和期望的一致。<ul><li>如果发现本地的Pod被修改，则Kubelet会做出相应的修改，比如删除Pod中某个容器时，则通过Docker Client删除该容器。 如果发现删除本节点的Pod，则删除相应的Pod，并通过Docker Client删除Pod中的容器。</li></ul></li><li>定时汇报当前节点的状态给 apiserver，以供调度的时候使用，通过cAdvisor监控节点和容器的资源。</li><li>用“kubernetes/pause”镜像为每个Pod创建一个容器。Pause容器用于接管Pod中所有其他容器的网络。每创建一个新的Pod，Kubelet都会先创建一个Pause容器，然后创建其他容器。</li></ul></li></ul><h1 id="kubelet源码分析"><a href="#kubelet源码分析" class="headerlink" title="kubelet源码分析"></a>kubelet源码分析</h1><p><a href="http://cizixs.com/2017/06/06/kubelet-source-code-analysis-part-1" target="_blank" rel="noopener">kubelet 源码分析：启动流程</a> （v1.5.0版本)</p><ul><li>解析参数配置信息等初始化准备后， 创建kubeDeps这个对象：<ul><li>其实它内部保存了 kubelet 各个重要组件的对象，之所以要把它作为参数传递，是为了实现 dependency injection。简单地说，就是把 kubelet 依赖的组件对象作为参数传进来，这样可以控制 kubelet 的行为。比如在测试的时候，只要构建 fake 的组件实现，就能很轻松进行测试。KubeDeps 包含的组件很多，下面列出一些：</li><li>CAdvisorInterface：提供 cAdvisor 接口功能的组件，负责收集容器的监控信息</li><li>DockerClient：docker 客户端，用来和 docker 交互</li><li>KubeClient：apiserver 客户端，用来和 api server 通信</li><li>Mounter：执行 mount 相关操作</li><li>NetworkPlugins：网络插件，执行网络设置工作</li><li>VolumePlugins：volume 插件，执行 volume 设置工作</li></ul></li><li>RunKubelet 函数:<ul><li>通过 builder 创建出来 Kubelet对象（pkg/kubelet/kubelet.go#NewMainKubelet）</li><li>根据运行模式，运行 Kubelet对象，各种组件以 goroutine运行启动<ul><li>异步事件驱动：syncLoop 是 kubelet 的主循环方法，它从不同的管道（文件、URL 和 apiserver）监听变化，并把它们汇聚起来。当有新的变化发生时，它会调用对应的处理函数，保证 pod 处于期望的状态。</li></ul></li></ul></li><li>kubelet对象 中包含的重要对象：<ul><li>podConfig：这个对象里面会从文件、网络和 apiserver 三个来源中汇聚节点要运行的 pod 信息，并通过管道发送出来，读取这个管道就能获取实时的 pod 最新配置</li><li>runtime：容器运行时，对容器引擎（docker 或者 rkt）的一层封装，负责调用容器引擎接口管理容器的状态，比如启动、暂停、杀死容器等</li><li>probeManager：如果 pod 配置了状态监测，那么 probeManager 会定时检查 pod 是否正常工作，并通过 statusManager 向 apiserver 更新 pod 的状态</li><li>volumeManager：负责容器需要的 volume 管理。检测某个 volume 是否已经 mount、获取 pod 使用的 volume 等</li><li>podWorkers：具体的执行者，每次有 pod 需要更新的时候都会发送给它</li><li>podManager：缓存了 pod 的信息，是所有需要该信息都会去访问的地方</li><li>nodeLister：能够读取 apiserver 中节点的信息</li></ul></li></ul><p> <a href="http://m.blog.csdn.net/zhonglinzhang/article/details/75005851" target="_blank" rel="noopener">kubelet源码分析－启动运行与信息处理</a><br><a href="http://cizixs.com/2017/06/07/kubelet-source-code-analysis-part-2" target="_blank" rel="noopener">kubelet 源码分析：pod 新建流程</a>（v1.5.0版本)：</p><ul><li>pod的创建顺序留意点：<ul><li>创建 pod 的数据目录，存放 volume 和 plugin 信息</li><li>如果定义了 PV，等待所有的 volume mount 完成（volumeManager 会在后台做这些事情）</li><li>如果有 image secrets，去 apiserver 获取对应的 secrets 数据</li><li>调用 container runtime 的 SyncPod 方法，去实现真正的容器创建逻辑<ul><li>通过 docker 创建出来一个运行的 pause 容器(Pause容器用于接管Pod中所 有其他容器的网络)。</li><li>网络配置：如果 pod 是主机模式，容器也是；其他情况下，<strong>容器会使用 None 网络模式，让 kubelet 的网络插件自己进行网络配置</strong>。</li></ul></li></ul></li></ul><hr><p>文章出处： <a href="https://yucs.github.io/2017/12/06/%202017-12-6-CNI/">https://yucs.github.io/2017/12/06/%202017-12-6-CNI/</a><br>如有出入请请教，文章持续更新中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;项目背景（XX银行客户）：私有云上要在K8S上跑像mysql这类状态的数据库服务，对性能和延时都比较敏感，并不像web偏应
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://yucs.github.io/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://yucs.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》笔记（二）</title>
    <link href="https://yucs.github.io/2017/12/01/2017-12-1-cryptology2/"/>
    <id>https://yucs.github.io/2017/12/01/2017-12-1-cryptology2/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2017-12-14T12:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h1><ul><li>可以保证消息的完整性，但不能对消息进行认证 （可以辨别出篡改，无法辨别出伪装）</li><li>散列值得长度是固定的，和消息长度无关。<br><img src="https://yucs.github.io/picture/单向散列函数.png" alt="单向散列函数"></li><li>性质：<ul><li>根据任意长度的消息计算出固定长度的散列值。</li><li>能够快速计算出散列值。  </li><li>如果两个消息体产生同个散列值称为碰撞,密码技术中所使用的单向散列函数必须具备抗碰撞性。</li><li><strong>哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值</strong></li><li><img src="https://yucs.github.io/picture/散列值碰撞.png" alt="散列值碰撞"></li><li>具备单向性：<br><img src="https://yucs.github.io/picture/散列值单向性.png" alt="散列值单向性"></li></ul></li><li>实际应用：<ul><li>MD5来验证是否同个文件软件。</li><li>数字签名处理过程非常耗时，因此一般不会对整个消息内容直接进行数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对整个散列值进行数字签名。</li><li>SHA-1的抗碰撞性已被攻破。</li><li>SHA-256,SHA-384,SHA-512这些统称SHA-2，尚未被攻破。</li><li>SHA3简介：由于近年来对传统常用Hash 函数如MD4、MD5、SHA0、SHA1、RIPENMD 等的成功攻击2012年10月2日，Keccak被选为NIST竞赛的胜利者， 成为SHA-3。</li></ul></li></ul><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><ul><li><p>公钥密码和数字签名：<br><img src="https://yucs.github.io/picture/密钥使用方式.png" alt="密钥使用方式"><br><img src="https://yucs.github.io/picture/密钥加密.png" alt="密钥加密"><br><img src="https://yucs.github.io/picture/数字签名.png" alt="数字签名"></p></li><li><p>数字签名是对消息的散列值签名：<br><img src="https://yucs.github.io/picture/数字签名流程.png" alt="数字签名流程"><br><img src="https://yucs.github.io/picture/数字签名流程2.png" alt="数字签名流程2"> </p></li><li>RAS的数字签名和验证：<br><img src="https://yucs.github.io/picture/RAS数字签名.png" alt="RAS数字签名"></li><li>数字签名不能保证机密性，在数字签名中，只有发送者才持有生成签名的私钥，防止否认。</li><li>对称密码的密钥是机密性的精华，单向散列函数的散列值是完整性的精华。</li><li>数字签名是非常重要的认证技术，但前提是用于验证签名的发送者的公钥没有被伪造，即要确认公钥是否合法，可以对公钥施加数字签名，之就是证书。</li></ul><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>公钥证书（public-Key Certificate PKC）由可信的认证机构（certification Authority ,CA）施加数字签名。公钥证书也简称证书。</p><ul><li><p>认证例子：<br><img src="https://yucs.github.io/picture/证书认证.png" alt="证书认证"></p></li><li><p>证书标准规范X.509:<br><img src="https://yucs.github.io/picture/X.509.png" alt="X.509"></p></li></ul><p>简单例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成证书</span></span><br><span class="line">openssl genrsa -out ca/ca-key.pem 1024  </span><br><span class="line"><span class="comment">#查看证书信息</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> cert.pem -noout -text</span><br></pre></td></tr></table></figure><ul><li><p>公钥基础设施（PKI）<br>PKI(public-key infrastructure)是为了能够有效地运用公钥而制定的一系列规范和规格的总称。</p><ul><li><p>组成要素： 用户：使用PKI的人，认证机构（CA）：颁发证书的人 ， 仓库：保存证书的数据库：<br><img src="https://yucs.github.io/picture/PKI.png" alt="pki">   </p></li><li><p>CA的工作：<br><img src="https://yucs.github.io/picture/PKI2.png" alt="pki2"></p></li><li><p>CRL(Certificate Revocation list): 证书作废清单，当用户的私钥丢失，被盗是，认证机构需要对证书进行作废。</p></li></ul></li><li><p>认证机构的层次：<br><img src="https://yucs.github.io/picture/PKI3.png" alt="pki3"></p></li><li><p>其他参考：</p><ul><li><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="noopener">数字证书原理</a>：文中首先解释了加密解密的一些基础知识和概念，然后通过一个加密通信过程的例子说明了加密算法的作用，以及数字证书的出现所起的作用。</li><li><a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">那些证书相关的玩意儿:X.509,PEM,DER,CRT,CER,KEY,CSR,P12</a><ul><li>CSR（Certificate Signing Request）：即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请。</li><li>PEM（Privacy Enhanced Mail）,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.</li></ul></li></ul></li></ul><h1 id="随机数-不可预测性的源泉"><a href="#随机数-不可预测性的源泉" class="headerlink" title="随机数-不可预测性的源泉"></a>随机数-不可预测性的源泉</h1><ul><li>随机数用来生成对称密钥，公钥密钥。</li><li>性质<ul><li>随机性：不存在统计学偏差，完全杂乱的数列</li><li>不可预测性：不能从过去的数列推测出下一个出现的数</li><li>不可重复性：除非将数列本身保存下来，否则不能重现相同的数列.</li><li><img src="https://yucs.github.io/picture/随机数.png" alt="随机数"></li><li>伪随机数生成器<ul><li>根据外部输入的种子生产伪随机数列<br><img src="https://yucs.github.io/picture/伪随机生成器.png" alt="伪随机生成器"></li><li>伪随机数生成器是公开，但种子需要自己保密，这类似密码算法是公开，而密钥要自己保密。</li><li>具体的伪随机数生成器</li><li>很多伪随机数生成器的库函数使用线性同余法编写，但是不具备不可预测性，不能用于密码技术。<br><img src="https://yucs.github.io/picture/线性同余法.png" alt="线性同余法"> </li><li>用密码实现伪随机数生成器<br><img src="https://yucs.github.io/picture/密码实现伪随机生成器.png" alt="密码实现伪随机生成器"> </li></ul></li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> <img src="https://yucs.github.io/picture/密码工具箱小结.png" alt="密码工具箱小结"> </p><ul><li>密钥是机密性的精华</li><li>散列值是完整性的精华</li><li>种子是不可预测性的精华</li><li>如果量子密码计算机进入实用领域，就能产生完美的密码技术</li><li>如果量子计算机比量子密码先进入实用领域，则使用目前的密码技术所产生的密文将全部破译。</li><li>即使真的拥有完美的密码技术，也不可能实现完美的安全性，因为必须会有人类-即不完美的我们参与其中。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单向散列函数&quot;&gt;&lt;a href=&quot;#单向散列函数&quot; class=&quot;headerlink&quot; title=&quot;单向散列函数&quot;&gt;&lt;/a&gt;单向散列函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可以保证消息的完整性，但不能对消息进行认证 （可以辨别出篡改，无法辨别出伪装）&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="区块链" scheme="https://yucs.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://yucs.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>《图解密码技术》笔记（一）</title>
    <link href="https://yucs.github.io/2017/11/25/2017-11-25-cryptology/"/>
    <id>https://yucs.github.io/2017/11/25/2017-11-25-cryptology/</id>
    <published>2017-11-24T16:00:00.000Z</published>
    <updated>2017-12-14T12:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术概要"><a href="#技术概要" class="headerlink" title="技术概要"></a><strong>技术概要</strong></h1><h2 id="密码技术概要图"><a href="#密码技术概要图" class="headerlink" title="密码技术概要图"></a>密码技术概要图</h2><p><img src="https://yucs.github.io/picture/1.5.png" alt="密码技术概要图"> </p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><p>伪随机生成器：是一种能够模拟生产随机数列的算法,承担着密钥生成的重要职责。如果生成随机数的算法不好，窃听者就能推测出密钥，从而带来通信机密性下降的风险。</p></li><li><p>数字签名：是一种能够保证完整性，提供认证，并防止否认的密码技术。</p></li><li><p>对称密码： 在加密和解密，使用同一个密钥的方式。</p></li><li><p>公钥密码/非对称密码: 是指在加密和解密时使用不同密钥的方式。</p></li><li><p>单向散列函数/哈希值/密码校验/消息摘要:所保证的并不是机密性，而是完整性.</p></li></ul><h1 id="密码与信息安全常识"><a href="#密码与信息安全常识" class="headerlink" title="密码与信息安全常识"></a><strong><em><em>密码与信息安全常识</em></em></strong></h1><h2 id="任何密码总有一天都会被破解"><a href="#任何密码总有一天都会被破解" class="headerlink" title="任何密码总有一天都会被破解"></a>任何密码总有一天都会被破解</h2><h2 id="密码只是信息安全的一部分"><a href="#密码只是信息安全的一部分" class="headerlink" title="密码只是信息安全的一部分"></a>密码只是信息安全的一部分</h2><h2 id="不要使用保密的密码算法"><a href="#不要使用保密的密码算法" class="headerlink" title="不要使用保密的密码算法"></a>不要使用保密的密码算法</h2><ul><li>密码算法的秘密，早晚会公诸于世！一旦密码，算法，详细信息被披露，依靠对算法本身进行保密，来确保机密信息的，密码系统也就土崩瓦解了。</li><li>开发高强度的密码算法是非常困难的。现在世界上公认的被认为强度较高的密码算法，几乎都是通过密码破译者长期还是破解未果而终活下来的。</li><li>试图通过对密码算法本身进行保密，来确保安全性的行为，一般称之为隐蔽性安全性，这种行为是危险且愚蠢的。</li></ul><h2 id="使用低强度的密码比不进行任何加密更危险"><a href="#使用低强度的密码比不进行任何加密更危险" class="headerlink" title="使用低强度的密码比不进行任何加密更危险"></a>使用低强度的密码比不进行任何加密更危险</h2><ul><li>容易让用户通过“密码”这个词，获得一种错误的安全感，进而导致用户在处理一些机密信息的时候麻痹大意。</li></ul><h1 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a><strong><em>对称密码</em></strong></h1><h2 id="通过XOR（异或）就可以实现高强度的密码"><a href="#通过XOR（异或）就可以实现高强度的密码" class="headerlink" title="通过XOR（异或）就可以实现高强度的密码"></a>通过XOR（异或）就可以实现高强度的密码</h2><ul><li>将明文A用密钥B进行加密，得到密文（A XOR B）</li><li>将密文（A XOR B）用密钥B进行加密，得到明文A</li><li>形象图参考如下：<br><img src="https://yucs.github.io/picture/xor.png" alt="xor图"></li><li>参考链接：<a href="http://www.ruanyifeng.com/blog/2017/05/xor.html" target="_blank" rel="noopener">XOR 加密简介</a></li></ul><h2 id="DES，三重DES"><a href="#DES，三重DES" class="headerlink" title="DES，三重DES"></a>DES，三重DES</h2><ul><li><p>DES(Data Encryption Standard)，即数据加密标准，是1977年美国联邦信息处理标准中所采用的一种对称密码。一直以来被美国以及其他国家的政府和银行等广泛使用，但是随着计算机的进步，现在的DES已经能够被暴力破解，强度大不如前了，现在我们<strong>不应该再使用DES了</strong>。</p></li><li><p>现在DES已经可以在现实的时间内被暴力破解，三重DES出于这个目的被开发出来的,但是处理速度不高，而且在安全性方面也逐渐显现出一些问题，也不推荐使用。</p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2></li><li><p>美国国家标准技术研究所 用 高级加密标准（Advanced Encryption Standard: AES）,用以取代DES。 最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法。</p></li><li><p><a href="http://blog.csdn.net/qq_28205153/article/details/55798628" target="_blank" rel="noopener">AES加密算法的详细介绍与实现</a>: AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。</p><ul><li>加密流程图：<br><img src="https://yucs.github.io/picture/AES.png" alt="AES加密流程图"></li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>然而用对称密码进行通信时，还会出现密钥的配送问题，及如何将密码安全的发送给接收者。为了解决密码配送问题，我们需要用公钥密码技术。</li><li>使用一种密钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性，巨大的密钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他类型的攻击。</li></ul><h1 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a><strong><em>分组密码的模式</em></strong></h1><ul><li>分组密码：是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）；一个分组的比特数就称为分组长度（block lenght）<ul><li>AES的分组长度可以从128比特,192比特和256比特进行选择，当选择128比特的分组长度时，AES一次加密128比特的明文，并生成128比特的密文。</li></ul></li><li>分组密码模式：分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。<br><img src="https://yucs.github.io/picture/block_cipher1.png" alt="分组密码模式图1"><br><img src="https://yucs.github.io/picture/block_cipher2.png" alt="分组密码模式图2"></li><li>分组密码有很多种模式，如果模式选择不恰当，就无法保证机密性。ECB模式中，明文中的一些规律就可以通过密文被识别出来。</li><li>安全性最差的模式是ECB模式，推荐使用CTR模式。</li></ul><h1 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h1><ul><li><p>公钥密码（piblic-key cryptography）中，密钥分为加密密钥和解密密钥两种。加密密钥称为公钥，解密密钥称为私钥（private key）。公钥和私钥是一一对应的，一对公钥和一对私钥统称为密钥对（key pair）。</p></li><li><p>对称密钥存在配送问题：<br><img src="https://yucs.github.io/picture/密钥配送问题.png" alt="密钥配送问题"></p></li><li><p>使用公钥密码 解决了配送问题 (但存在公钥认证问题)：<br><img src="https://yucs.github.io/picture/公钥密码发送消息.png" alt="公钥密码发送消息"></p></li></ul><h2 id="RAS"><a href="#RAS" class="headerlink" title="RAS"></a>RAS</h2><p>  <img src="https://yucs.github.io/picture/RAS.png" alt="ras"></p><ul><li>RSA算法基于一个十分简单的数学难题：RSA使用因式分解的原理，两个大质数相乘很容易，但大数分解质因子很难.即：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</li></ul><h2 id="ECC（椭圆曲线密码）"><a href="#ECC（椭圆曲线密码）" class="headerlink" title="ECC（椭圆曲线密码）"></a>ECC（椭圆曲线密码）</h2><ul><li>通过将椭圆上的特点点进行特殊的乘法运算来实现，它的特点是所需的密钥长度比RSA短.</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>使用公钥密码能解决密钥配送的问题，现代计算机和互联网所使用的密码技术都得益于公钥密码。</li><li>公钥密码是基于数学上的困难的问题来保证机密性。可见，对称密码和公钥密码是两种根本不同的思路。</li><li>公钥密码解决了密钥配送问题，但针对公钥密码能够进行中间人攻击。</li><li>密钥的价值等价于明文的价值</li><li>密钥生成：生成密钥的最好方法是使用随机数，因为密钥需要具备不易被她人推测的性质。密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的。 </li><li>密码配送：使用公钥密码外，还有一种是Diffie-Hellman 密钥交换。</li></ul><h2 id="高深的密码学-复杂的区块链，其实也可以通俗易懂"><a href="#高深的密码学-复杂的区块链，其实也可以通俗易懂" class="headerlink" title="高深的密码学+复杂的区块链，其实也可以通俗易懂:"></a><a href="http://rdc.hundsun.com/portal/article/750.html" target="_blank" rel="noopener">高深的密码学+复杂的区块链，其实也可以通俗易懂</a>:</h2><ul><li>RSA又慢又不安全，所以比特币和以太坊都不采用，而是使用了更安全的椭圆曲线算法。</li><li>ECC来做非对称加密基础算法。ECC算法用很短的密钥就能达到RSA2048的安全强度，而且计算速度有数量级的提高，所以目前应用很普遍，国密中的SM2就是基于ECC算法的。</li><li>强烈不建议使用RSA，原因如下：<ul><li>容易被破解：RSA-768可以在3个小时内破解，1024在理论上100小时内也可以破解。所以使用RSA，长度起步要2048。但是数学家彼得·舒尔研究了一个针对整数分解问题的量子算法 (舒尔算法)，理论上破解2048的RSA在100秒之内(好在量子机还未投入使用)。<ul><li>密钥长度加到2048可以提升安全，但是计算过慢。</li></ul></li></ul></li></ul><h1 id="混合密码系统"><a href="#混合密码系统" class="headerlink" title="混合密码系统"></a>混合密码系统</h1><ul><li>公钥密码的处理远远低于对称密码</li><li><p>公钥密码难以抵挡中间人攻击</p></li><li><p>混合密码系统: 结合对称密码，公钥密码和伪随机生成器这三种密码技术，创造出了一种兼具对称密码和公钥密码优点的密码方式。混合密码系统解决了公钥密码速度过慢的问题，并通过公钥密码解决了对称密码的密钥配送问题。密码软件PGP、以及网络上密码通信所使用的SSL/TLS都运用了混合密码系统。</p><h2 id="加密流程："><a href="#加密流程：" class="headerlink" title="加密流程："></a>加密流程：</h2><p><img src="https://yucs.github.io/picture/加密流程.png" alt="加密流程"></p><ul><li>伪随机数生成器被用于产生会话密钥。</li><li>用对称密码加密消息，用公钥密码加密会话秘钥。即:会话秘钥是对称密码的密钥，同时也是公钥密码的明文。<h2 id="解密流程："><a href="#解密流程：" class="headerlink" title="解密流程："></a>解密流程：</h2></li><li><img src="https://yucs.github.io/picture/解密流程.png" alt="解密流程"></li></ul></li></ul><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul><li>混合密码系统中运用了对称密码和公钥密码两种密码方式，无论其中任何一方的密钥过短都可能遭到集中攻击，考虑到长期运用的情况，公钥密码的强度应该要高于对称密码，因为对称密码的会话密钥被破译只会影响本次通信内容，而公钥密码一旦被破译，所有相同公钥加密的通信内容就都能被破译了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术概要&quot;&gt;&lt;a href=&quot;#技术概要&quot; class=&quot;headerlink&quot; title=&quot;技术概要&quot;&gt;&lt;/a&gt;&lt;strong&gt;技术概要&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;密码技术概要图&quot;&gt;&lt;a href=&quot;#密码技术概要图&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="区块链" scheme="https://yucs.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://yucs.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>学好编程语言的方法论（心得）</title>
    <link href="https://yucs.github.io/2017/11/22/2017-11-22-languge/"/>
    <id>https://yucs.github.io/2017/11/22/2017-11-22-languge/</id>
    <published>2017-11-21T16:00:00.000Z</published>
    <updated>2017-12-14T12:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对编程语言的态度"><a href="#对编程语言的态度" class="headerlink" title="对编程语言的态度"></a>对编程语言的态度</h1><ul><li><strong>语言只是个工具，往一个具体领域学习研究才是王道</strong>：（当然，具体项目选择语言还是很重要的：该语言开发效率，性能，可读性，现有可用库是否满足项目等等<strong>语言生态环境</strong>，就看如何trade-off选择了），所以我不太喜欢用Python工程师，golang工程师来给工程师打标签，而ios/前端/web后端/分布式系统 这样带有领域方向的标签才合适。</li></ul><ul><li><strong>不要抵触学习新语言心理，按需学习</strong>：无论开源项目,还是项目开发选中的语言，毕竟都有它的优势，需要就学习，毕竟学习一门语言也不会太耗时间（因为我想学语言最耗时间的在于学习库,无论语言，语言特性，语言背后的原理，都能很快就学习掌握的,尤其学习c++后，<strong>毕竟主流语言基本都是面向对象，而精髓是万变不离其宗，重要的还是抽象 即 理解掌握‘设计模式’的核心思想</strong>)，也能加深对语言的理解，发现自己真正欣赏动心的语言。</li></ul><ul><li><p>现在开发语言都在相互借鉴学习，个人觉得发展趋势：<strong>追求简洁性，开发效率，兼顾性能，更加注重业务逻辑，而非语言本生带来的心智负担</strong>（eg:语法层面引用代替指针或者如golang语言弱化指针，垃圾回收机制）。</p></li><li><p>个人觉得<strong>深刻学习语言最好的方式就是： 看用该语言写的开源项目源码，当然这涉及到动力问题，所以去研究自己感兴趣的领域，开源项目就很重要的，无论是工作需要，还是自己兴趣</strong>，以我为例，大学刚开始工作时候，研究linux内核开发，glusterfs分布式系统,也就学习C/C++，shell脚本了，学习初步研究openstack时候就学习python，研究docker也就学习了golang语言。</p></li></ul><h1 id="如何写出质量高的代码"><a href="#如何写出质量高的代码" class="headerlink" title="如何写出质量高的代码"></a>如何写出质量高的代码</h1><ul><li><p><strong>最基本</strong>：理解语言底层原理，而不是简单的使用</p></li><li><p><strong>看用该语言写的开源项目源码</strong> </p><ul><li><p>看逻辑流程时适合小中断，多注意源码组织布局，多注意该 类/模块 其他函数（封装/抽象）,猜测该类模块基本功能，这样我想对于项目组织理解会更深刻，<strong>能潜移默化的提高你代码的质量</strong>。</p></li><li><p><strong>高质量代码看多了，对代码品味高了</strong>，自己的写的代码质量当然也差不了多少，此外还能。so,我相信经常看开源项目的人写出来的代码质量都不会差的。</p></li><li>能学到使用该语言的技巧，间接学习丰富该语言的库等等，肯定都<strong>有很多让自己眼睛一亮，学习借鉴的地方</strong>，这样写自己代码就有底气自信多了。</li></ul></li><li><p>就如不懂github就不是一个合格的工程师一样， 某种意义讲，没有看过开源源码的也不算是个合格的工程师。</p></li><li><p>理解掌握 <strong>设计模式</strong>的核心思想：</p><ul><li>封装变化（抽象)</li><li>多用组合，少用继承</li><li>针对接口编程，而不针对实现编程。</li></ul></li></ul><ul><li>对于go语言，看开源项目，多关注代码组织结构时，也多注意包中的*_test.go，在没没文档情况下，相对容易理解该包作用。</li></ul><h1 id="语言对比理解"><a href="#语言对比理解" class="headerlink" title="语言对比理解"></a>语言对比理解</h1><ul><li><p><strong>c/c++</strong>： 偏向底层基础软件，编译性语言，高性能，嵌入式等方向，指针，无垃圾回收机制，开发效率相对低，有一定的心智负担，可以<strong>理解为高级语言中的汇编语言</strong></p></li><li><p><strong>python</strong>：追求开发效率，解释性语言，性能相对低，<a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">The Zen of Python</a>,可用于脚本开发</p></li><li><p><strong>java</strong>: <strong>成熟稳定，生态环境比较好</strong>，编译性语言，语法冗长，可用于企业级应用开发，性能高的基础软件，大数据生态。。很多大公司稳妥的选择。</p></li><li><p><strong>golang</strong>:（个人）设计优雅，interface接口的设计很好的面向对象的思想，工程性开发语言（语言层面有一定的强制性风格要求），编译型<strong>基于goroutine和channel的通信（语言层面支持）简洁高效的支持多并发</strong>，可用于高性能高并发系统开发</p></li><li><p><strong>scala</strong>: 函数式编程，追求速度，跑在JVM上，Java互操作性， 不可变，无副作用，函数是一等公民等函数式编程思维方式跟面向对象思想有一定的区别，对于开发人能力相对比较有要求。个人觉得对于函数式编程思想，对于数据的处理更贴近。。用于大数据领域（python ,java，scala对比：<a href="https://www.zhihu.com/question/19748408/answer/62527490" target="_blank" rel="noopener">Scala 是一门怎样的语言，具有哪些优缺点？</a>紫杉的回答）</p></li></ul><h1 id="资源推荐"><a href="#资源推荐" class="headerlink" title="资源推荐"></a>资源推荐</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><ul><li><a href="http://blog.csdn.net/u010129347/article/details/46601571" target="_blank" rel="noopener">学习推荐书籍（golang ,web ,机器学习)</a> golang 部分</li></ul><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul><li>《java编程思想》（Think in java）<br>有深度精炼的书，不适合新手比，但提升必看的书（较有深度的书），层面设计也多跟C++做对比，比较深度的<strong>分析讲解面向对象的编程理念</strong>（即<strong>更多解释WHY 这么设计</strong>，而非只是语法层面）。</li><li>《java核心技术 卷一》<br> 适合新手看，中规中矩，语法层面更细些。</li></ul><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><ul><li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="noopener">Scala课堂</a>&amp;&amp;<a href="http://twitter.github.io/effectivescala/index-cn.html" target="_blank" rel="noopener">Effective Scala</a></li><li>《scala编程(Programming in Scala)》&amp;&amp;《快学scala》</li><li>可以参考 <a href="https://github.com/jacksu/utils4s" target="_blank" rel="noopener">https://github.com/jacksu/utils4s</a> 中 scala语法学习 资源部分</li><li><a href="https://www.zhihu.com/question/19748408/answer/62527490" target="_blank" rel="noopener">Scala 是一门怎样的语言，具有哪些优缺点？</a>&amp;<a href="http://blog.csdn.net/scgaliguodong123_/article/details/46277159" target="_blank" rel="noopener">为什么选择Scala，它在大数据处理方面有何优势？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对编程语言的态度&quot;&gt;&lt;a href=&quot;#对编程语言的态度&quot; class=&quot;headerlink&quot; title=&quot;对编程语言的态度&quot;&gt;&lt;/a&gt;对编程语言的态度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;语言只是个工具，往一个具体领域学习研究才是王道&lt;/strong&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="https://yucs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="个人见解" scheme="https://yucs.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3/"/>
    
    
      <category term="编程语言" scheme="https://yucs.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="个人见解" scheme="https://yucs.github.io/tags/%E4%B8%AA%E4%BA%BA%E8%A7%81%E8%A7%A3/"/>
    
  </entry>
  
</feed>
